/* Ace by Javier Santo Domingo (j-a-s-d@coderesearchlabs.com) */

package ace.binary;

import ace.Ace;
import ace.arrays.ByteArrays;
import java.io.ByteArrayOutputStream;
import java.io.DataOutputStream;
import java.io.File;
import java.io.FileInputStream;
import java.io.InputStream;
import java.util.Arrays;

/**
 * Useful binary data fluent and flexible composing class.
 */
public class BinaryComposer extends Ace {

	/**
	 * Enumerates the supported binary composition modes.
	 */
	public enum Mode {
		ARRAY, STREAM
	};
	private Mode _mode = Mode.STREAM;
	private ByteArrayOutputStream _bos = null;
	private DataOutputStream _out = null;
	private byte[] _buffer = null;

	/**
	 * Default constructor which sets the binary composition mode to the default (STREAM).
	 */
	public BinaryComposer() {
		reset();
	}

	/**
	 * Constructor taking the desired binary composition mode.
	 * 
	 * @param mode 
	 */
	public BinaryComposer(final Mode mode) {
		_mode = mode;
		reset();
	}

	/**
	 * Constructor taking a file as the initial data.
	 * 
	 * @param file 
	 */
	public BinaryComposer(final File file) {
		set(file);
	}

	/**
	 * Constructor taking an input stream as the initial data.
	 * 
	 * @param content 
	 */
	public BinaryComposer(final InputStream content) {
		set(content);
	}

	/**
	 * Constructor taking a string as the initial data.
	 * 
	 * @param content 
	 */
	public BinaryComposer(final String content) {
		set(content);
	}

	/**
	 * Constructor taking a char array as the initial data.
	 * 
	 * @param content 
	 */
	public BinaryComposer(final char[] content) {
		set(content);
	}

	/**
	 * Constructor taking a byte array as the initial data.
	 * 
	 * @param content 
	 */
	public BinaryComposer(final byte[] content) {
		set(content);
	}

	/**
	 * Constructor taking a generated byte array as the initial data
	 * specified by its length and the filling.
	 * 
	 * @param length 
	 * @param filling 
	 */
	public BinaryComposer(final int length, final byte filling) {
		set(length, filling);
	}

	/**
	 * Resets the content data.
	 * 
	 * @return itself
	 */
	public final BinaryComposer reset() {
		if (_mode.equals(Mode.STREAM)) {
			_bos = new ByteArrayOutputStream();
			_out = new DataOutputStream(_bos);
		} else {
			_buffer = new byte[] {};
		}
		return this;
	}

	/**
	 * Sets the content data with the specified byte array.
	 * 
	 * @param data
	 * @return itself
	 */
	public final BinaryComposer set(final byte[] data) {
		if (_mode.equals(Mode.STREAM)) {
			reset();
			append(data);
		} else {
			_buffer = data;
		}
		return this;
	}

	/**
	 * Sets the content data with the specified char array.
	 * 
	 * @param data
	 * @return itself
	 */
	public final BinaryComposer set(final char[] data) {
		return set(data == null ? null : new String(data).getBytes());
	}

	/**
	 * Sets the content data with the specified string.
	 * 
	 * @param string
	 * @return itself
	 */
	public final BinaryComposer set(final String string) {
		return set(string == null ? null : string.getBytes());
	}

	/**
	 * Sets the content data with the specified input stream
	 * reading the specified size from it.
	 * 
	 * @param inputStream
	 * @param size
	 * @return itself
	 */
	public final BinaryComposer set(final InputStream inputStream, final int size) {
		try {
			final byte[] arr = new byte[size];
			inputStream.read(arr, 0, arr.length);
			return set(arr);
		} catch (final Exception e) {
			GEH.setLastException(e);
			return null;
		}
	}

	/**
	 * Sets the content data with the specified input stream
	 * reading the available size from it.
	 * 
	 * @param inputStream
	 * @return itself
	 */
	public final BinaryComposer set(final InputStream inputStream) {
		try {
			return set(inputStream, inputStream.available());
		} catch (final Exception e) {
			GEH.setLastException(e);
			return null;
		}
	}

	/**
	 * Sets the content data with the content of the supplied file.
	 * 
	 * @param file
	 * @return itself
	 */
	public final BinaryComposer set(final File file) {
		try {
			return set(new FileInputStream(file), (int) file.length());
		} catch (final Exception e) {
			GEH.setLastException(e);
			return null;
		}
	}

	/**
	 * Sets the content data with a byte array generated
	 * by the supplied length and the supplied filling.
	 * 
	 * @param length
	 * @param filling
	 * @return itself
	 */
	public final BinaryComposer set(final int length, final byte filling) {
		final byte[] content = new byte[length];
		Arrays.fill(content, filling);
		return set(content);
	}

	/**
	 * Gets the content data as a byte array.
	 * 
	 * @return the content data as a byte array
	 */
	public final byte[] get() {
		if (_mode.equals(Mode.STREAM)) {
			try {
				_out.close();
				final byte[] result = _bos.toByteArray();
				_bos.close();
				return result;
			} catch (final Exception e) {
				GEH.setLastException(e);
				return null;
			}
		} else {
			return _buffer;
		}
	}

	/**
	 * Gets the content data as a char array.
	 * 
	 * @return the content data as a char array
	 */
	public final char[] getAsCharArray() {
		final byte[] bytes = get();
		final char[] result = new char[bytes.length];
		int index = 0;
		for (final byte b : bytes) {
			result[index++] = (char) b;
		}
		return result;
	}

	/**
	 * Gets the content data as a string.
	 * 
	 * @return the content data as a string
	 */
	public final String getAsString() {
		return new String(getAsCharArray());
	}

	/**
	 * Gets the content data as a hex string.
	 * 
	 * @return the content data as a hex string
	 */
	public final String getAsHexString() {
		return Hex.fromByteArray(get());
	}

	/**
	 * Appends the content data with the specified byte array.
	 * 
	 * @param data
	 * @return itself
	 */
	public final BinaryComposer append(final byte[] data) {
		if (_mode.equals(Mode.STREAM)) {
			try {
				_out.write(data);
			} catch (final Exception e) {
				GEH.setLastException(e);
			}
		} else {
			_buffer = ByteArrays.concat(_buffer, data);
		}
		return this;
	}

	/**
	 * Appends the content data with a byte array generated
	 * by the supplied length and the supplied filling.
	 * 
	 * @param length
	 * @param filling
	 * @return itself
	 */
	public final BinaryComposer append(final int length, final byte filling) {
		final byte[] content = new byte[length];
		Arrays.fill(content, filling);
		return append(content);
	}

	/**
	 * Appends the content data with the specified char array.
	 * 
	 * @param data
	 * @return itself
	 */
	public final BinaryComposer append(final char[] data) {
		return append(data == null ? null : new String(data).getBytes());
	}

	/**
	 * Appends the content data with the specified string.
	 * 
	 * @param string
	 * @return itself
	 */
	public final BinaryComposer append(final String string) {
		return append(string == null ? null : string.getBytes());
	}

	/**
	 * Appends the content data with the specified input stream
	 * reading the specified size from it.
	 * 
	 * @param inputStream
	 * @param size
	 * @return itself
	 */
	public final BinaryComposer append(final InputStream inputStream, final int size) {
		try {
			final byte[] arr = new byte[size];
			inputStream.read(arr, 0, arr.length);
			append(arr);
		} catch (final Exception e) {
			GEH.setLastException(e);
		}
		return this;
	}

	/**
	 * Gets the content data length.
	 * 
	 * @return the content data length
	 */
	public final int size() {
		return _mode.equals(Mode.STREAM) ? _out.size() : _buffer.length;
	}

}
